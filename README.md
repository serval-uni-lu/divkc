# DivKC: A Divide-and-Conquer Approach to Knowledge Compilation

This repository contains the programs and data associated with
the article 'DivKC: A Divide-and-Conquer Approach to Knowledge Compilation'.

## Results

The `results` contains the raw results that are presented in the article as well
as more detailed versions of the tables available in the article.

## D4

The folder `D4` contains a slightly modified version of the D4 compiler.
The modification is only present to also include the unconstrained
varables in the generated .nnf file therefore simplifying further
usage of the d-DNNF.

## Usage

To use our approach, the `cppddnnf`, `splitter`, `projection`, and `D4` projects will need to be compiled
by following the instructions in the respective folders.

### Dependencies

The dependencies on Debian-based systems can be installed as follows:
```
apt install g++ make zlib1g-dev libboost-dev libgmp-dev libgmpxx4ldbl ninja-build libboost-program-options-dev libboost-random-dev
```

### Building

These commands should build the individual projects. Detailed instructions are
given in each subdirectory.

```
cd cppddnnf
g++ gen.cpp -o gen
./gen
ninja clean
ninja
cd ..

cd splitter
g++ gen.cpp -o gen
./gen
ninja clean
ninja
cd ..

cd projection
g++ gen.cpp -o gen
./gen
ninja clean
ninja
cd ..

cd D4/d4
make clean
make -j
cd ../..
```

Given that compilation can require large amounts of memory, an apptainer script
is proposed in the `D4` directory. The container will limit `D4` to 16 GB of memory and
one hour of computation.

```
apptainer build --fakeroot d4.sif d4.def
```

The resulting container (`d4.sif`) can be used just like the native executable.

### Splitter

The folder `splitter` contains the used splitting heuristic.
A singularity script is also provided in the folder.

### Projection

The folder `projection` contains the program used for CNF projection.
A singularity script is also provided in the folder.

### Approximate Algorithms

The folder `cppddnnf` contains the C++ utilities necessary to work with our compiled form.


### Example Usage

#### Compiling a Formula

First, we need to compute a projection set for the formula `t.cnf` by using the `splitter`.
```
./splitter/build/splitter --cnf t.cnf --nb 4 > t.cnf.log
cat t.cnf.log t.cnf > t.cnf.proj
```

We then project the formula by using the `projection` tool
which generates the CNF representation of the projected formula and the upper bound
as described in the paper:
```
./projection/build/projection --cnf t.cnf.proj
```

We then use `D4` to compile the projected formula and the upper bound to d-DNNF.
```
./D4/d4/d4 -dDNNF "t.cnf.proj.p" -out="t.cnf.pnnf"
./D4/d4/d4 -dDNNF "t.cnf.proj.pup" -out="t.cnf.unnf"

appmc "t.cnf" 1000 0.01
```

We now have a d-DNNF representation as described in the paper.
Note that the files generated during this entire process are somewhat important.
The approximate counting and sampling executables expect as input the path to the
original CNF formula `t.cnf` and as a consequence they expect to find
`t.cnf.proj.log` as generated by `projection` and the formulae
`t.cnf.pnnf` and `t.cnf.unnf` as generated above.
The remaining files were useful during the process but are no longer used afterwards and can be deleted.

For your convenience, a script called `compile_formula.sh` is provided to perform the above
calls and remove the unused files (however, the script uses the default parameters).
Usage: `bash compile_formula.sh t.cnf`.

#### Approximate Model Counting

Once the formula has been compiled, you can perform approximate model counting as follows:
```
./cppddnnf/build/appmc --cnf t.cnf
```

This will output the estimates over time in CSV format with the header: `N,Y,Yl,Yh`
, where `N` is the number of solutions used, `Y` is the estimate and `Yl` and `Yh` are
the estimated lower and upper bounds computed with the central limit theorem.

#### Approximate Uniform Random Sampling

Once the formula has been compiled, you can perform approximate model counting as follows:
```
./cppddnnf/build/sampler --cnf t.cnf --k 50 --nb 10
```
This will use a buffer size of `50` and generate `10` samples.

The program will start by printing either
`c true uniformity` or `c heuristic based uniformity` to show if the algorithm
used is exact or heuristic based. This depends on the formula and on the buffer size.

The algorithm will then print the solutions.
Each solution is a list of signed integers representing the literals and separated by spaces. Each solution
is terminated by `0`.

`./cppddnnf/build/rsampler` can be used instead of `./cppddnnf/build/sampler`.
More details can be found in `cppddnnf/README.md`.
